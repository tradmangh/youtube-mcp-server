import { YoutubeTranscript, TranscriptResponse } from "youtube-transcript";
import { TranscriptParams, SearchTranscriptParams } from '../types.js';

/**
 * Service for interacting with YouTube video transcripts
 */
export class TranscriptService {
  // No YouTube API key needed for transcripts, but we'll implement the same pattern
  private initialized = false;

  constructor() {
    // No initialization needed
  }

  private initialize() {
    if (this.initialized) return;
    // No API key needed for transcripts, but we'll check if language is set
    this.initialized = true;
  }

  /**
   * Normalize transcript text for better readability
   * - Removes extra whitespace
   * - Normalizes line breaks
   * - Improves punctuation spacing
   */
  private normalizeText(text: string): string {
    return text
      // Replace HTML entities
      .replace(/&amp;/g, '&')
      .replace(/&lt;/g, '<')
      .replace(/&gt;/g, '>')
      .replace(/&quot;/g, '"')
      .replace(/&#39;/g, "'")
      // Remove multiple spaces
      .replace(/\s+/g, ' ')
      // Normalize line breaks
      .replace(/\n+/g, '\n')
      // Trim
      .trim();
  }

  /**
   * Join transcript segments into clean, normalized text
   */
  private joinTranscriptSegments(segments: TranscriptResponse[]): string {
    // Join all text segments with spaces
    const fullText = segments
      .map(segment => this.normalizeText(segment.text))
      .join(' ');
    
    // Normalize the final text
    return this.normalizeText(fullText);
  }

  /**
   * Get a clean, normalized transcript suitable for LLM processing
   * This is the improved version that addresses the feature request
   */
  async get_transcript({ 
    videoId, 
    language = process.env.YOUTUBE_TRANSCRIPT_LANG || 'en',
    preferAutoGenerated = false
  }: TranscriptParams): Promise<any> {
    try {
      this.initialize();
      
      // Note: The youtube-transcript library automatically prefers official captions
      // over auto-generated ones when no specific preference is given.
      // The library doesn't expose a way to explicitly choose auto-generated captions,
      // but the preferAutoGenerated parameter is included for future extensibility.
      
      const config = language ? { lang: language } : undefined;
      const transcript = await YoutubeTranscript.fetchTranscript(videoId, config);
      
      if (!transcript || transcript.length === 0) {
        throw new Error('No transcript available for this video');
      }
      
      // Create a clean, normalized plain-text version
      const plainText = this.joinTranscriptSegments(transcript);
      
      // Also provide timestamped version for optional use
      const timestampedSegments = transcript.map(item => {
        const seconds = item.offset / 1000;
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = Math.floor(seconds % 60);
        const formattedTime = `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
        
        return {
          timestamp: formattedTime,
          text: this.normalizeText(item.text)
        };
      });
      
      return {
        videoId,
        language: transcript[0]?.lang || language,
        plainText,
        timestampedSegments,
        segmentCount: transcript.length
      };
    } catch (error: any) {
      // Provide clear error messages
      if (error.message?.includes('No transcripts are available')) {
        throw new Error(`Transcripts are not available for video ${videoId}. The video may not have captions enabled.`);
      }
      if (error.message?.includes('No transcripts are available in')) {
        throw new Error(`No transcript available in language '${language}' for video ${videoId}. ${error.message}`);
      }
      if (error.message?.includes('Video unavailable')) {
        throw new Error(`Video ${videoId} is unavailable or does not exist.`);
      }
      if (error.message?.includes('Transcript disabled')) {
        throw new Error(`Transcripts are disabled for video ${videoId}.`);
      }
      throw new Error(`Failed to get transcript: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  /**
   * Get the transcript of a YouTube video
   */
  async getTranscript({ 
    videoId, 
    language = process.env.YOUTUBE_TRANSCRIPT_LANG || 'en' 
  }: TranscriptParams): Promise<any> {
    try {
      this.initialize();
      
      // YoutubeTranscript.fetchTranscript only accepts videoId
      const transcript = await YoutubeTranscript.fetchTranscript(videoId);
      
      return {
        videoId,
        language,
        transcript
      };
    } catch (error) {
      throw new Error(`Failed to get transcript: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  /**
   * Search within a transcript
   */
  async searchTranscript({ 
    videoId, 
    query,
    language = process.env.YOUTUBE_TRANSCRIPT_LANG || 'en' 
  }: SearchTranscriptParams): Promise<any> {
    try {
      this.initialize();
      
      const transcript = await YoutubeTranscript.fetchTranscript(videoId);
      
      // Search through transcript for the query
      const matches = transcript.filter(item => 
        item.text.toLowerCase().includes(query.toLowerCase())
      );
      
      return {
        videoId,
        query,
        matches,
        totalMatches: matches.length
      };
    } catch (error) {
      throw new Error(`Failed to search transcript: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  
  /**
   * Get transcript with timestamps
   */
  async getTimestampedTranscript({ 
    videoId, 
    language = process.env.YOUTUBE_TRANSCRIPT_LANG || 'en' 
  }: TranscriptParams): Promise<any> {
    try {
      this.initialize();
      
      const transcript = await YoutubeTranscript.fetchTranscript(videoId);
      
      // Format timestamps in human-readable format
      const timestampedTranscript = transcript.map(item => {
        const seconds = item.offset / 1000;
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = Math.floor(seconds % 60);
        const formattedTime = `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
        
        return {
          timestamp: formattedTime,
          text: item.text,
          startTimeMs: item.offset,
          durationMs: item.duration
        };
      });
      
      return {
        videoId,
        language,
        timestampedTranscript
      };
    } catch (error) {
      throw new Error(`Failed to get timestamped transcript: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
}